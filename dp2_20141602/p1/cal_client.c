/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "cal.h"



// for cal

#define MMAX 100

int stack[MMAX];
int top;

void init_stack();
int push(int);
int pop();
int get_stack_top();
int is_stack_empty();
int is_operator(int);
int is_legal(char*);

int precedence(int);
void postfix(char*, char*);

int calc(char*, CLIENT*);



int add(struct two_in arg, CLIENT *clnt);
int sub(struct two_in arg, CLIENT *clnt);
int mul(struct two_in arg, CLIENT *clnt);
int divv(struct two_in arg, CLIENT *clnt);

void
cal_1(char *host)
{
	CLIENT *clnt;
	int  *result;
	struct two_in  arg;

#ifndef	DEBUG
	clnt = clnt_create (host, CAL, ASSI_1, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */


	char exp[256] = "2*3+6/2-4";
	char pf[256];
	
	
	arg.a = 3;
	arg.b = 4;

	fgets(exp, 256, stdin);

	int r;


	postfix(pf, exp);
	r = calc(pf, clnt);



	printf("The answer is %d\n", r);


#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}




int add(struct two_in arg, CLIENT *clnt){
	int *res;
	res = addition_1(&arg, clnt);
	if (res == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	return *res;
}
int sub(struct two_in arg, CLIENT *clnt){
	int *res;
	res = subtraction_1(&arg, clnt);
	if (res == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	
	return *res;
}


int mul(struct two_in arg, CLIENT *clnt){
	int *res;

	res = multiplication_1(&arg, clnt);
	if (res == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	
	return *res;
}


int divv(struct two_in arg, CLIENT *clnt){
	int *res;
	res = division_1(&arg, clnt);
	if (res == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	return *res;
}






int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	cal_1 (host);
exit (0);
}




void init_stack(void){
    top = -1;
}

int push(int t){

    if (top >= MMAX - 1){
        printf("\n    Stack overflow.");
        return -1;
    }

    stack[++top] = t;
    return t;
}

int pop(void){
    if (top < 0){
        printf("\n   Stack underflow.");
        return -1;
    }
    return stack[top--];
}


int get_stack_top(void){
    return (top < 0) ? -1 : stack[top];
}

int is_stack_empty(void){
    return (top < 0);
}

int is_operator(int k){
    return (k == '+' || k == '-' || k == '*' || k == '/');
}

int is_legal(char *s){
    int f = 0;
    while (*s){
        while (*s == ' '){
            s++;
        }

        if (is_operator(*s)){
            f--;
        }
        else{
            f++;
            while (*s != ' '){
                s++;
            }
        }
        if (f < 1) break;
        s++;
    }
    return (f == 1);
}

int precedence(int op){
    if (op == '(') return 0;
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    else return 3;
}

void postfix(char *dst, char *src){
    char c;
    init_stack();
    while (*src){
        if (*src == '('){
            push(*src);
            src++;
        }
        else if (*src == ')'){
            while (get_stack_top() != '('){
                *dst++ = pop();
                *dst++ = ' ';
            }
            pop();
            src++;
        }
        else if (is_operator(*src)){
            while (!is_stack_empty() &&
                precedence(get_stack_top()) >= precedence(*src)){
                *dst++ = pop();
                *dst++ = ' ';
            }
            push(*src);
            src++;
        }
        else if (*src >= '0' && *src <= '9'){
            do{
                *dst++ = *src++;
            } while (*src >= '0' && *src <= '9');
            *dst++ = ' ';
        }
        else{
            src++;
        }
    }

    while (!is_stack_empty()){
        *dst++ = pop();
        *dst++ = ' ';
    }
    dst--;
    *dst = 0;
}

int calc(char *p, CLIENT *CLNT){
    int i;

	struct two_in arg;
    init_stack();
    while (*p){
        if (*p >= '0' && *p <= '9'){
            i = 0;
            do{
                i = i * 10 + *p - '0';
                p++;
            } while (*p >= '0' && *p <= '9');
            push(i);
        }
        else if (*p == '+'){
			arg.a = pop();
			arg.b = pop();
            push(add(arg, CLNT));
            p++;
        }
        else if (*p == '*'){

			arg.a = pop();
			arg.b = pop();
			
            push(mul(arg, CLNT));
            p++;
        }
        else if (*p == '-'){
			arg.b = pop();
			arg.a = pop();
            push(sub(arg, CLNT));
            p++;
        }
        else if (*p == '/'){
			arg.b = pop();
			arg.a = pop();
            push(divv(arg, CLNT));
            p++;
        }
        else{
            p++;
        }
    }
    return pop();
}

